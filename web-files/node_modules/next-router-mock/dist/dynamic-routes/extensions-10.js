"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("next/dist/next-server/lib/router/utils");
// @ts-ignore
const normalize_page_path_1 = require("next/dist/next-server/server/normalize-page-path");
// @ts-ignore
const MemoryRouter_1 = require("../MemoryRouter");
require("./path-parser");
/**
 * Register URL paths with the router; this can include any static and dynamic paths your app might use.
 * Any provided dynamic paths will have their slugs parsed and added to the ParsedUrlQuery on the router
 * when a route is pushed.
 */
MemoryRouter_1.MemoryRouter.prototype.registerPaths = function (paths) {
    this.pathParser = createPathParserFromPaths(paths);
};
const createPathParserFromPaths = (paths) => {
    const matchers = utils_1.getSortedRoutes(paths.map((path) => normalize_page_path_1.normalizePagePath(path))).map((path) => ({
        pathname: path,
        match: utils_1.getRouteMatcher(utils_1.getRouteRegex(path)),
    }));
    return (url) => {
        var _a, _b;
        const pathname = (_a = url.pathname) !== null && _a !== void 0 ? _a : "";
        const isDynamic = utils_1.isDynamicRoute(pathname);
        // @ts-ignore
        const matcher = matchers.find((matcher) => !!matcher.match(pathname));
        const match = matcher ? matcher.match(pathname) : false;
        // When pushing to a dynamic route with un-interpolated slugs passed in the pathname, the assumption is that
        // a query dictionary will be provided, so instead of using the match we interpolate the route from
        // the provided query
        const parsedQuery = isDynamic ? url.query : match ? match : {};
        return Object.assign(Object.assign({}, url), { pathname: (_b = matcher === null || matcher === void 0 ? void 0 : matcher.pathname) !== null && _b !== void 0 ? _b : pathname, query: Object.assign(Object.assign({}, url.query), parsedQuery) });
    };
};
//# sourceMappingURL=extensions-10.js.map